"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Stream = void 0;
const streamAddMultistreamTarget_js_1 = require("../funcs/streamAddMultistreamTarget.js");
const streamCreate_js_1 = require("../funcs/streamCreate.js");
const streamCreateClip_js_1 = require("../funcs/streamCreateClip.js");
const streamDelete_js_1 = require("../funcs/streamDelete.js");
const streamGet_js_1 = require("../funcs/streamGet.js");
const streamGetAll_js_1 = require("../funcs/streamGetAll.js");
const streamGetClips_js_1 = require("../funcs/streamGetClips.js");
const streamRemoveMultistreamTarget_js_1 = require("../funcs/streamRemoveMultistreamTarget.js");
const streamStartPull_js_1 = require("../funcs/streamStartPull.js");
const streamTerminate_js_1 = require("../funcs/streamTerminate.js");
const streamUpdate_js_1 = require("../funcs/streamUpdate.js");
const sdks_js_1 = require("../lib/sdks.js");
const fp_js_1 = require("../types/fp.js");
class Stream extends sdks_js_1.ClientSDK {
    /**
     * Create a stream
     *
     * @remarks
     * The only parameter you are required to set is the name of your stream,
     * but we also highly recommend that you define transcoding profiles
     * parameter that suits your specific broadcasting configuration.
     * \
     * \
     * If you do not define transcoding rendition profiles when creating the
     * stream, a default set of profiles will be used. These profiles include
     * 240p,  360p, 480p and 720p.
     * \
     * \
     * The playback policy is set to public by default for new streams. It can
     * also be added upon the creation of a new stream by adding
     * `"playbackPolicy": {"type": "jwt"}`
     */
    async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamCreate_js_1.streamCreate)(this, request, options));
    }
    /**
     * Retrieve streams
     */
    async getAll(streamsonly, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamGetAll_js_1.streamGetAll)(this, streamsonly, options));
    }
    /**
     * Retrieve a stream
     */
    async get(id, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamGet_js_1.streamGet)(this, id, options));
    }
    /**
     * Update a stream
     */
    async update(id, streamPatchPayload, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamUpdate_js_1.streamUpdate)(this, id, streamPatchPayload, options));
    }
    /**
     * Delete a stream
     *
     * @remarks
     * This will also suspend any active stream sessions, so make sure to wait
     * until the stream has finished. To explicitly interrupt an active
     * session, consider instead updating the suspended field in the stream
     * using the PATCH stream API.
     */
    async delete(id, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamDelete_js_1.streamDelete)(this, id, options));
    }
    /**
     * Terminates a live stream
     *
     * @remarks
     * `DELETE /stream/{id}/terminate` can be used to terminate an ongoing
     * session on a live stream. Unlike suspending the stream, it allows the
     * streamer to restart streaming even immediately, but it will force
     * terminate the current session and stop the recording.
     * \
     * \
     * A 204 No Content status response indicates the stream was successfully
     * terminated.
     */
    async terminate(id, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamTerminate_js_1.streamTerminate)(this, id, options));
    }
    /**
     * Start ingest for a pull stream
     *
     * @remarks
     * `POST /stream/{id}/start-pull` can be used to start ingest for a stream
     * configured with a pull source. If the stream has recording configured,
     * it will also start recording.
     * \
     * \
     * A 204 No Content status response indicates the stream was successfully
     * started.
     */
    async startPull(id, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamStartPull_js_1.streamStartPull)(this, id, options));
    }
    /**
     * Create a clip
     */
    async createClip(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamCreateClip_js_1.streamCreateClip)(this, request, options));
    }
    /**
     * Retrieve clips of a livestream
     */
    async getClips(id, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamGetClips_js_1.streamGetClips)(this, id, options));
    }
    /**
     * Add a multistream target
     */
    async addMultistreamTarget(id, targetAddPayload, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamAddMultistreamTarget_js_1.streamAddMultistreamTarget)(this, id, targetAddPayload, options));
    }
    /**
     * Remove a multistream target
     */
    async removeMultistreamTarget(id, targetId, options) {
        return (0, fp_js_1.unwrapAsync)((0, streamRemoveMultistreamTarget_js_1.streamRemoveMultistreamTarget)(this, id, targetId, options));
    }
}
exports.Stream = Stream;
//# sourceMappingURL=stream.js.map