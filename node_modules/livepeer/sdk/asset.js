"use strict";
/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Asset = void 0;
const assetCreate_js_1 = require("../funcs/assetCreate.js");
const assetCreateViaUrl_js_1 = require("../funcs/assetCreateViaUrl.js");
const assetDelete_js_1 = require("../funcs/assetDelete.js");
const assetGet_js_1 = require("../funcs/assetGet.js");
const assetGetAll_js_1 = require("../funcs/assetGetAll.js");
const assetUpdate_js_1 = require("../funcs/assetUpdate.js");
const sdks_js_1 = require("../lib/sdks.js");
const fp_js_1 = require("../types/fp.js");
class Asset extends sdks_js_1.ClientSDK {
    /**
     * Retrieve assets
     */
    async getAll(options) {
        return (0, fp_js_1.unwrapAsync)((0, assetGetAll_js_1.assetGetAll)(this, options));
    }
    /**
     * Upload an asset
     *
     * @remarks
     * To upload an asset, your first need to request for a direct upload URL
     * and only then actually upload the contents of the asset.
     * \
     * \
     * Once you created a upload link, you have 2 options, resumable or direct
     * upload. For a more reliable experience, you should use resumable uploads
     * which will work better for users with unreliable or slow network
     * connections. If you want a simpler implementation though, you should
     * just use a direct upload.
     *
     * ## Direct Upload
     * For a direct upload, make a PUT request to the URL received in the url
     * field of the response above, with the raw video file as the request
     * body. response above:
     *
     * ## Resumable Upload
     * Livepeer supports resumable uploads via Tus. This section provides a
     * simple example of how to use tus-js-client to upload a video file.
     * \
     * \
     * From the previous section, we generated a URL to upload a video file to
     * Livepeer on POST /api/asset/request-upload. You should use the
     * tusEndpoint field of the response to upload the video file and track the
     * progress:
     *
     * ```
     * # This assumes there is an `input` element of `type="file"` with id
     * `fileInput` in the HTML
     *
     * const input = document.getElementById('fileInput');
     *
     * const file = input.files[0];
     *
     * const upload = new tus.Upload(file, {
     *   endpoint: tusEndpoint, // URL from `tusEndpoint` field in the
     * `/request-upload` response
     *   metadata: {
     *     filename,
     *     filetype: 'video/mp4',
     *   },
     *   uploadSize: file.size,
     *   onError(err) {
     *     console.error('Error uploading file:', err);
     *   },
     *   onProgress(bytesUploaded, bytesTotal) {
     *     const percentage = ((bytesUploaded / bytesTotal) * 100).toFixed(2);
     *     console.log('Uploaded ' + percentage + '%');
     *   },
     *   onSuccess() {
     *     console.log('Upload finished:', upload.url);
     *   },
     * });
     *
     * const previousUploads = await upload.findPreviousUploads();
     *
     * if (previousUploads.length > 0) {
     *   upload.resumeFromPreviousUpload(previousUploads[0]);
     * }
     *
     * upload.start();
     *
     * ```
     *
     * > Note: If you are using tus from node.js, you need to add a custom URL
     * storage to enable resuming from previous uploads. On the browser, this
     * is enabled by default using local storage. In node.js, add urlStorage:
     * new tus.FileUrlStorage("path/to/tmp/file"), to the UploadFile object
     * definition above.
     */
    async create(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, assetCreate_js_1.assetCreate)(this, request, options));
    }
    /**
     * Upload asset via URL
     */
    async createViaUrl(request, options) {
        return (0, fp_js_1.unwrapAsync)((0, assetCreateViaUrl_js_1.assetCreateViaUrl)(this, request, options));
    }
    /**
     * Retrieves an asset
     */
    async get(assetId, options) {
        return (0, fp_js_1.unwrapAsync)((0, assetGet_js_1.assetGet)(this, assetId, options));
    }
    /**
     * Patch an asset
     */
    async update(assetId, assetPatchPayload, options) {
        return (0, fp_js_1.unwrapAsync)((0, assetUpdate_js_1.assetUpdate)(this, assetId, assetPatchPayload, options));
    }
    /**
     * Delete an asset
     */
    async delete(assetId, options) {
        return (0, fp_js_1.unwrapAsync)((0, assetDelete_js_1.assetDelete)(this, assetId, options));
    }
}
exports.Asset = Asset;
//# sourceMappingURL=asset.js.map