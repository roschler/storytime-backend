import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as operations from "../models/operations/index.js";
export declare class Stream extends ClientSDK {
    /**
     * Create a stream
     *
     * @remarks
     * The only parameter you are required to set is the name of your stream,
     * but we also highly recommend that you define transcoding profiles
     * parameter that suits your specific broadcasting configuration.
     * \
     * \
     * If you do not define transcoding rendition profiles when creating the
     * stream, a default set of profiles will be used. These profiles include
     * 240p,  360p, 480p and 720p.
     * \
     * \
     * The playback policy is set to public by default for new streams. It can
     * also be added upon the creation of a new stream by adding
     * `"playbackPolicy": {"type": "jwt"}`
     */
    create(request: components.NewStreamPayload, options?: RequestOptions): Promise<operations.CreateStreamResponse>;
    /**
     * Retrieve streams
     */
    getAll(streamsonly?: string | undefined, options?: RequestOptions): Promise<operations.GetStreamsResponse>;
    /**
     * Retrieve a stream
     */
    get(id: string, options?: RequestOptions): Promise<operations.GetStreamResponse>;
    /**
     * Update a stream
     */
    update(id: string, streamPatchPayload: components.StreamPatchPayload, options?: RequestOptions): Promise<operations.UpdateStreamResponse>;
    /**
     * Delete a stream
     *
     * @remarks
     * This will also suspend any active stream sessions, so make sure to wait
     * until the stream has finished. To explicitly interrupt an active
     * session, consider instead updating the suspended field in the stream
     * using the PATCH stream API.
     */
    delete(id: string, options?: RequestOptions): Promise<operations.DeleteStreamResponse>;
    /**
     * Terminates a live stream
     *
     * @remarks
     * `DELETE /stream/{id}/terminate` can be used to terminate an ongoing
     * session on a live stream. Unlike suspending the stream, it allows the
     * streamer to restart streaming even immediately, but it will force
     * terminate the current session and stop the recording.
     * \
     * \
     * A 204 No Content status response indicates the stream was successfully
     * terminated.
     */
    terminate(id: string, options?: RequestOptions): Promise<operations.TerminateStreamResponse>;
    /**
     * Start ingest for a pull stream
     *
     * @remarks
     * `POST /stream/{id}/start-pull` can be used to start ingest for a stream
     * configured with a pull source. If the stream has recording configured,
     * it will also start recording.
     * \
     * \
     * A 204 No Content status response indicates the stream was successfully
     * started.
     */
    startPull(id: string, options?: RequestOptions): Promise<operations.StartPullStreamResponse>;
    /**
     * Create a clip
     */
    createClip(request: components.ClipPayload, options?: RequestOptions): Promise<operations.CreateClipResponse>;
    /**
     * Retrieve clips of a livestream
     */
    getClips(id: string, options?: RequestOptions): Promise<operations.GetClipsResponse>;
    /**
     * Add a multistream target
     */
    addMultistreamTarget(id: string, targetAddPayload: components.TargetAddPayload, options?: RequestOptions): Promise<operations.AddMultistreamTargetResponse>;
    /**
     * Remove a multistream target
     */
    removeMultistreamTarget(id: string, targetId: string, options?: RequestOptions): Promise<operations.RemoveMultistreamTargetResponse>;
}
//# sourceMappingURL=stream.d.ts.map